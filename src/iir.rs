extern crate test;

use num_traits::Zero;
use std::iter::Sum;
use std::ops::{Div, Mul, Sub};

pub fn iir_filter<T>(b: &[T], a: &[T], input: &[T]) -> Vec<T>
where
    T: Copy + Clone + Zero + Mul + Div<Output = T> + Sub<Output = T> + Sum<<T as Mul>::Output>,
{
    let mut output = vec![T::zero(); input.len()];

    let sum = |values: &[T], coeffs: &[T], n: usize| -> T {
        coeffs
            .iter()
            .take(n + 1)
            .enumerate()
            .map(|(j, &c)| c * values[n - j])
            .sum()
    };

    let a0 = *a.first().unwrap();

    for (n, _) in input.iter().enumerate() {
        output[n] = (sum(input, b, n) - sum(&output, a, n)) / a0;
    }

    output
}

#[cfg(test)]
mod tests {
    use super::*;
    use num_complex::Complex64;
    use test::Bencher;

    const BR: [f64; 4] = [0.16666667, 0.5, 0.5, 0.16666667];
    const AR: [f64; 4] = [1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17];
    const XR: [f64; 20] = [
        -0.917843918645,
        0.141984778794,
        1.20536903482,
        0.190286794412,
        -0.662370894973,
        -1.00700480494,
        -0.404707073677,
        0.800482325044,
        0.743500089861,
        1.01090520172,
        0.741527555207,
        0.277841675195,
        0.400833448236,
        -0.2085993586,
        -0.172842103641,
        -0.134316096293,
        0.0259303398477,
        0.490105989562,
        0.549391221511,
        0.9047198589,
    ];

    const BC: [(f64, f64); 3] = [(0.3339, -0.5573), (0.5591, -0.7406), (0.1648, -0.0743)];
    const AC: [(f64, f64); 1] = [(0.0, 2.0)];
    const XC: [(f64, f64); 20] = [
        (0.0496, 0.8871),
        (0.6477, 0.8209),
        (0.6992, 0.9695),
        (0.9586, 0.7425),
        (0.6845, 0.0556),
        (0.6139, 0.0842),
        (0.5202, 0.5712),
        (0.1096, 0.1592),
        (0.3339, 0.5573),
        (0.5591, 0.7406),
        (0.1648, 0.0743),
        (0.4051, 0.3390),
        (0.1327, 0.7347),
        (0.0356, 0.6056),
        (0.9634, 0.2060),
        (0.1658, 0.9736),
        (0.0512, 0.6754),
        (0.6978, 0.5226),
        (0.5115, 0.6229),
        (0.0914, 0.0996),
    ];

    #[test]
    fn iir_reals() {
        let expected = [
            -0.15297398950031305,
            -0.4352578290502175,
            -0.13604339698849033,
            0.6975033265479628,
            0.6564446924690288,
            -0.4354824532561056,
            -1.0892394611529292,
            -0.5376765495627545,
            0.517049992313214,
            1.0522497471553531,
            0.961854300373645,
            0.695690094009605,
            0.4243562950955321,
            0.19626223182178915,
            -0.027835124463393313,
            -0.21172191545011781,
            -0.17474556222276072,
            0.06925840890119488,
            0.3854458743074388,
            0.6517708388193052,
        ];

        let out = iir_filter(&BR, &AR, &XR);

        assert_eq!(out, expected);
    }

    fn cpx_vec(re_im: &[(f64, f64)]) -> Vec<Complex64> {
        re_im
            .iter()
            .map(|(re, im)| Complex64::new(*re, *im))
            .collect()
    }

    #[test]
    fn iir_complex() {
        let bc = cpx_vec(&BC);
        let ac = cpx_vec(&AC);
        let xc = cpx_vec(&XC);

        let expected = cpx_vec(&[
            (0.134280305, -0.255471135),
            (0.18618957499999997, -0.67923611),
            (0.027919629999999945, -0.9089692250000001),
            (-0.08746344500000001, -1.0052700200000002),
            (-0.27494569, -0.7663256),
            (-0.369363405, -0.44446610499999994),
            (-0.274228685, -0.5072756150000001),
            (-0.05278100499999999, -0.47330946000000007),
            (0.031660930000000004, -0.36471125),
            (0.00904644, -0.61436519),
            (0.0, -0.526974695),
            (-0.05628506500000001, -0.309260055),
            (0.030440230000000013, -0.4819955900000001),
            (0.26031569000000004, -0.529823645),
            (-0.022337434999999982, -0.490675775),
            (-0.13423847000000003, -0.6700056999999999),
            (0.29044938000000003, -0.69065858),
            (0.13671998000000002, -0.5763649399999999),
            (-0.09708795000000003, -0.67686477),
            (-0.00697817500000001, -0.493575775),
        ]);

        let out = iir_filter(bc.as_slice(), ac.as_slice(), xc.as_slice());

        assert_eq!(out, expected);
    }

    #[bench]
    fn bench_iir_reals(b: &mut Bencher) {
        b.iter(|| iir_filter(&BR, &AR, &XR));
    }

    #[bench]
    fn bench_iir(b: &mut Bencher) {
        let bc = cpx_vec(&BC);
        let ac = cpx_vec(&AC);
        let xc = cpx_vec(&XC);

        b.iter(|| iir_filter(bc.as_slice(), ac.as_slice(), xc.as_slice()));
    }
}
